import katex from "katex";
import "katex/dist/katex.min.css";

import { marked } from "marked";
import { convert } from "html-to-text";

export default function () {
  function renderMarkdown(markdown: string) {
    // marked will replace \[ \] \( and \) by simply [ } ( ), so wee need to add an extra \ to escape it.
    // in fact we add an extra \ to all isolated \ to escape them.
    markdown = markdown.replace(/([^\\])\\([^\\])/g, "$1\\\\$2");
    const html = marked.parse(markdown);
    return html;
  }
  // Function to render LaTeX to HTML using KaTeX
  function renderLatexString(latexString: string) {
    try {
      return katex.renderToString(latexString, {
        throwOnError: false,
      });
    } catch (error) {
      console.error("Error rendering LaTeX string:", error);
      return latexString; // Return original string if there's an error
    }
  }
  function replaceHTMLEscapedChars(text: string) {
    return text
      .trim()
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&amp;/g, "&")
      .replace(/&#39;/g, "'");
  }

  function renderKatex(text: string, allowInlineMath = false) {
    if (!text) return text;
    let processed = false;
    // Replace display equations
    let result = text.replace(/\\\[(.*?)\\\]/gs, (match, p1) => {
      processed = true;
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    // Replace inline equations
    result = result.replace(/\\\((.*?)\\\)/gs, (match, p1) => {
      processed = true;
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    // Replace inline equations
    result = result.replace(/\$\$(.*?)\$\$/gs, (match, p1) => {
      processed = true;
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    // Replace inline equations with a single $, as long as the text is short
    result = result.replace(/\$(.*?)\$/gs, (match, p1) => {
      processed = true;
      if (p1.length < 50) return renderLatexString(replaceHTMLEscapedChars(p1));
      return p1;
    });
    // Replace weird hybrid equation generated by GPT
    result = result.replace(/\\(\\(?:sum|frac).*?)\\\\/gs, (match, p1) => {
      processed = true;
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    if (!processed && allowInlineMath) {
      // if we find a \frac or \sum we assume it's a math equation
      if (result.match(/\\(?:sum|frac|math|begin|text)/s)) {
        result = renderLatexString(replaceHTMLEscapedChars(result));
      }
    }
    return result;
  }

  const defaultOptions = {
    wordwrap: 100,
    formatters: {
      headingFormatter: function (elem: {tagName: string[]}, walk: Function, builder: object) {
        const level = Math.max(1, parseInt(elem.tagName[1], 10) - 0); // Get the heading level (e.g., 1 for <h1>, 2 for <h2>)
        const hashes = "#".repeat(level); // Create the appropriate number of hashes
        builder.openBlock(elem);
        builder.addInline(`\n\n${hashes} `);
        walk(elem.children, builder);
        builder.addInline("\n");
        builder.closeBlock(elem);
      },
    },
    selectors: [
      { selector: "h1", format: "headingFormatter" },
      { selector: "h2", format: "headingFormatter" },
      { selector: "h3", format: "headingFormatter" },
      { selector: "h4", format: "headingFormatter" },
      { selector: "h5", format: "headingFormatter" },
      { selector: "h6", format: "headingFormatter" },
    ],
  };

  const formatService = {
    htmlToMarkdown: (htmlContent: string, options = defaultOptions) =>
      convert(htmlContent, options).replace(/\n\n/g, "\n"),
    setDefaultOptions: (options: object) => {
      Object.assign(defaultOptions, options);
    },
    renderLatexString,
    renderKatex,
    renderMarkdown
  };

  return formatService;
}
